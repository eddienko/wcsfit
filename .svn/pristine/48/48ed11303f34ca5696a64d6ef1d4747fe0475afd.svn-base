/*

$Id: cir_classify.c,v 1.11 2012/12/05 11:50:23 jim Exp $

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <imcore.h>
#include <cir_classify.h>
#include <tools.h>

static void write_pa(char *, fitsfile *, float);
static void tidy();

static fitsfile *iptr = NULL;
static float *workspace = NULL;
static float *areal = NULL;

static float *core_flux,*core1_flux,*core2_flux,*core3_flux,*core4_flux;
static float *core5_flux,*peak_height,*peak_mag,*ellipticity,*iso_flux;
static float *total_flux,*cls,*sig,*xpos,*ypos,*core6_flux,*posang,*skylev;

static int status = 0;

static char *cols32[14] = {"Core_flux","Core1_flux","Core2_flux","Core3_flux",
			   "Core4_flux","Peak_height","Ellipticity",
			   "Isophotal_flux","Total_flux","Core5_flux",
                           "X_coordinate","Y_coordinate","Position_angle",
                           "Skylev"};

static char *cols80[15] = {"Aper_flux_3","Aper_flux_1","Aper_flux_4",
			   "Aper_flux_5","Aper_flux_6","Peak_height",
			   "Ellipticity","Isophotal_flux","",
			   "Aper_flux_7","X_coordinate","Y_coordinate",
                           "Position_angle","Sky_level","Aper_flux_2"};

static int ncols;
static float xmin;
static float xmax;
static float ymin;
static float ymax;
static float pixlim;

#define FRAMECUT 0.05

extern int cir_classify(char *infile, char *expkey, float minsize, 
			char *errmsg);

/*+
 *  Name:
 *      cir_classify
 *
 *  Purpose:
 *      Classify objects in a catalogue
 *
 *  Description:
 *      Objects in a catalogue are classfied based on their image properties.
 *      The catalogue should have columns that have been generated by imcore
 *      to make sure that the correct information is available.  The 
 *      classification scheme is similar to that used at the APM.
 *
 *  Language:
 *      C
 *
 *  Arguments:
 *      infile = char * (Given)
 *          The name of the input FITS table catalogue.  Required columns
 *          and header values are listed in the notes below.
 *      expkey = char * (Given)
 *          The name of the keyword in the input catalogue that specifies
 *          the exposure time.
 *      minsize = int (Given)
 *          The minimum sized object to use in the analysis
 *      errmsg = char * (Returned)
 *          Error message generated if something went wrong during the
 *          processing.
 *
 *  Returned values:
 *      Standard cirdr status values (see cirdr.h)
 *
 *  Notes:
 *      The following columns are used by the classifier:
 *          32 column cats      80 columns cats
 *          --------------      ---------------
 *          Core_flux           Aper_flux_3
 *          Core1_flux          Aper_flux_1
 *          Core2_flux          Aper_flux_4
 *          Core3_flux          Aper_flux_5
 *          Core4_flux          Aper_flux_6
 *          Core5_flux          Aper_flux_7
 *                              Aper_flux_2
 *          Peak_height         Peak_height
 *          Ellipticity         Ellipticity
 *          Isophotal_flux      Isophotal_flux
 *          Total_flux          
 *          Areal_1_profile     Areal_1_profile
 *          Areal_2_profile     Areal_2_profile
 *          Areal_3_profile     Areal_3_profile
 *          Areal_4_profile     Areal_4_profile
 *          Areal_5_profile     Areal_5_profile
 *          Areal_6_profile     Areal_6_profile
 *          Areal_7_profile     Areal_7_profile
 *          Areal_8_profile     Areal_8_profile
 *          X_coordinate        X_coordinate
 *          Y_coordinate        Y_coordinate
 *          Position_angle      Position_angle
 *          Skylev              Sky_level
 *
 *      The Following header values are used by the classifier
 *          threshol = float (sigma)
 *              The detection threshold used by imcore
 *          skylevel = float (ADUs)
 *              The mean background level in the image
 *          skynoise = float (ADUs)
 *              The mean sky noise in the image
 *          rcore = float 
 *              The core radius for default profile fit
 *          seeing = float (pixels)
 *              The mean seeing on the image
 *          expkey = float (seconds)
 *              The exposure time of the image.  This is read from the
 *              keyword specified in the 'expkey' input argument.
 *
 *  Dependencies:
 *      cfitsio, cir_stats.c
 *
 *  Authors:
 *      Mike Irwin (CASU, IoA)
 *      Jim Lewis (CASU, IoA)
 *
 *  Copyright:
 *      Copyright (C) 2002-2005 Cambridge Astronomy Survey Unit.
 *      All Rights Reserved.
 *
+*/  

extern int cir_classify(char *infile, char *expkey, float minsize, 
			char *errmsg) {
    char msg[BUFSIZ],colname[BUFSIZ],**cols;
    int colnum,anynull,i,n,iap,i1,i2,class,classcol,statcol,nxout,nyout,ncread;
    float fwhm,*work,pkht,ell,ap,delap,area,junk,core,arg,moff,moffexp;
    
    /* Open the input file */

    status = 0;
    (void)fits_open_file(&iptr,infile,READWRITE,&status);
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: Can't open file %s -- %s",infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Read the header information you need */

    (void)fits_read_key(iptr,TFLOAT,"THRESHOL",&thresh,msg,&status);
    (void)fits_read_key(iptr,TFLOAT,"SKYLEVEL",&skylevel,msg,&status);
    (void)fits_read_key(iptr,TFLOAT,"SKYNOISE",&skynoise,msg,&status);
    (void)fits_read_key(iptr,TFLOAT,"RCORE",&rcore,msg,&status);
    (void)fits_read_key(iptr,TFLOAT,"SEEING",&fwhm,msg,&status);
/*     (void)fits_read_key(iptr,TFLOAT,expkey,&exptime,msg,&status); */
    (void)fits_read_key(iptr,TINT,"NXOUT",&nxout,NULL,&status);
    (void)fits_read_key(iptr,TINT,"NYOUT",&nyout,NULL,&status);
    xmin = FRAMECUT*(float)nxout;
    xmax = (1.0 - FRAMECUT)*(float)nxout;
    ymin = FRAMECUT*(float)nyout;
    ymax = (1.0 - FRAMECUT)*(float)nyout;
    pixlim = minsize;
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: missing header info %s -- %s",infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Trap for WFCAM */

    (void)fits_read_key(iptr,TSTRING,"INSTRUME",msg,NULL,&status);
    moffexp = 0.6;
    if (status != 0) {
	status = 0;
    } else if (strcmp(msg,"WFCAM") == 0) {
	moffexp = 0.75;
    }	

    /* Get the number of columns and decide which column labels to use */

    (void)fits_get_num_cols(iptr,&ncols,&status);
    switch (ncols) {
    case 32:
	cols = cols32;
	ncread = 17;
	break;
    case 80:
	cols = cols80;
	ncread = 18;
	break;
    default:
	ncread = 0;
	(void)sprintf(errmsg,
		      "CLASSIFY: Don't recognise catalogues with %d columns\n",
		      ncols);
	tidy();
	return(CIR_FATAL);
    }

    /* Now get some workspace for the columns */

    (void)fits_get_num_rows(iptr,&nrows,&status);
    workspace = cir_malloc(nrows*ncread*sizeof(float));
    core_flux = workspace;
    core1_flux = workspace + nrows;
    core2_flux = workspace + 2*nrows;
    core3_flux = workspace + 3*nrows;
    core4_flux = workspace + 4*nrows;
    core5_flux = workspace + 5*nrows;
    peak_height = workspace + 6*nrows;
    peak_mag = workspace + 7*nrows;
    ellipticity = workspace + 8*nrows;
    iso_flux = workspace + 9*nrows;
    total_flux = workspace + 10*nrows;
    cls = workspace + 11*nrows;
    sig = workspace + 12*nrows;
    xpos = workspace + 13*nrows;
    ypos = workspace + 14*nrows;
    posang = workspace + 15*nrows;
    skylev = workspace + 16*nrows;
    if (ncread == 18) 
	core6_flux = workspace + 17*nrows;
    else
	core6_flux = NULL;
    
    /* Get the information about each column */

    (void)fits_get_colnum(iptr,CASEINSEN,cols[0],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core_flux,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[1],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core1_flux,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[2],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core2_flux,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[3],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core3_flux,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[4],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core4_flux,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[5],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,peak_height,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[6],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,ellipticity,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[7],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,iso_flux,&anynull,
			&status);
    if (ncols == 32) {
        (void)fits_get_colnum(iptr,CASEINSEN,cols[8],&colnum,&status);
        (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,total_flux,
			    &anynull,&status);
    }
    (void)fits_get_colnum(iptr,CASEINSEN,cols[10],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,xpos,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[11],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,ypos,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[12],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,posang,&anynull,
			&status);
    (void)fits_get_colnum(iptr,CASEINSEN,cols[13],&colnum,&status);
    (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,skylev,&anynull,
			&status);
    if (ncread == 18) {
	(void)fits_get_colnum(iptr,CASEINSEN,cols[14],&colnum,&status);
	(void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core6_flux,
			    &anynull,&status);
    }
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: missing column info %s -- %s",infile,
		      msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Convert fluxes to "magnitudes" */

    for (i = 0; i < nrows; i++) {
	core_flux[i] = COREMAG(core_flux[i],0.0,1.0);
	core1_flux[i] = COREMAG(core1_flux[i],0.0,1.0);
	core2_flux[i] = COREMAG(core2_flux[i],0.0,1.0);
	core3_flux[i] = COREMAG(core3_flux[i],0.0,1.0);
	core4_flux[i] = COREMAG(core4_flux[i],0.0,1.0);
	moff = 1.0/(1.0 - pow((thresh/max(peak_height[i],thresh)),moffexp));
	iso_flux[i] = COREMAG(moff*iso_flux[i],0.0,1.0);
	peak_mag[i] = COREMAG(peak_height[i],skynoise,0.1);
    }
    if (core6_flux != NULL)
	for (i = 0; i < nrows; i++)
	    core6_flux[i] = COREMAG(core6_flux[i],0.0,1.0);
    if (ncols == 32) {
	for (i = 0; i < nrows; i++)
	    total_flux[i] = COREMAG(total_flux[i],0.0,1.0);
    }

    /* Check for core5 flux and convert if it exists (it definitely will
       exist for 80 column format */

    (void)fits_get_colnum(iptr,CASEINSEN,cols[9],&colnum,&status);
    if (status != 0) {
	status = 0;
	for (i = 0; i < nrows; i++) 
	    core5_flux[i] = total_flux[i];
    } else {
        (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,core5_flux,
			    &anynull,&status);
	for (i = 0; i < nrows; i++)
  	    core5_flux[i] = COREMAG(core5_flux[i],0.0,1.0);
    }

    /*  Now get the areal profile information. You'll need this in a sec */

    areal = cir_malloc(NAREAL*nrows*sizeof(float));
    for (i = 0; i < NAREAL; i++) {
        sprintf(colname,"Areal_%d_profile",i+1);
        (void)fits_get_colnum(iptr,CASEINSEN,colname,&colnum,&status);
        (void)fits_read_col(iptr,TFLOAT,colnum,1,1,nrows,NULL,(areal+i*nrows),
			    &anynull,&status);
    }
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: missing column info %s -- %s",infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* What is the seeing like? */

    poor = 0;
    if (fwhm > max(5.0,rcore*sqrt(2.0)))
        poor = 1;

    /* Ok, now call the routine that does all the work */

    classify();

    /* Right, now get a better estimate of the seeing */

    work = cir_malloc(nrows*sizeof(float));
    n = 0;
    for (i = 0; i < nrows; i++) {
        pkht = peak_height[i];
        ell = ellipticity[i];
	core = core_flux[i];
        if (cls[i] == -1.0 && ell < elllim && core < corlim && 
            pkht > 10.0*thresh) { 
	    ap = log(0.5*pkht/thresh)/log(2.0) + 1.0;
            iap = (int)ap;
            delap = ap - (float)iap;
            if (iap > 0 && iap < NAREAL && areal[nrows+i] > 0.0) {
	        i1 = (iap-1)*nrows + i;
                i2 = iap*nrows + i;
                area = areal[i1]*(1.0 - delap) + areal[i2]*delap;
                work[n++] = 2.0*sqrt(area/M_PI);
            }
        }
    }
    if (n > 2) { 
        medstat(work,n,&fwhm,&junk);
       
        /* Allow for finite pixel size */

        arg = 0.25*M_PI*fwhm*fwhm - 1;
        fwhm = 2.0*sqrt(max(0.0,arg/M_PI));
       
    } else
        fwhm = -1.0;
    free(work);

    /* Ok, write the new column information */

    (void)fits_get_colnum(iptr,CASEINSEN,"Classification",&classcol,&status);
    (void)fits_get_colnum(iptr,CASEINSEN,"Statistic",&statcol,&status);
    (void)fits_write_col(iptr,TFLOAT,classcol,1,1,nrows,cls,&status);
    (void)fits_write_col(iptr,TFLOAT,statcol,1,1,nrows,sig,&status);
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: couldn't write column info %s -- %s",
            infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Write header results */

    (void)fits_update_key(iptr,TFLOAT,"SEEING",&fwhm,"Average FWHM (pixels)",
			  &status);
    (void)fits_update_key(iptr,TFLOAT,"ELLIPTIC",&fitell,
			  "Average stellar ellipticity (1-b/a)",&status);
    write_pa(infile,iptr,fitpa);
    class = 1;
    (void)fits_update_key(iptr,TLOGICAL,"CLASSIFD",&class,
			  "Class flag: -1 stellar, 1 non-stellar, 0 noise",
			  &status);
    (void)fits_update_key(iptr,TFLOAT,"SATURATE",&avsat,
			  "Average saturation level in frame",&status);
    switch (ncols) {
    case 32:
	(void)fits_update_key(iptr,TFLOAT,"APCORPK",&apcpkht,
			      "Stellar aperture correction - peak height",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR1",&apcor1,
			      "Stellar aperture correction - 1/2x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR",&apcor,
			      "Stellar aperture correction - 1x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR2",&apcor2,
			      "Stellar aperture correction - sqrt(2)x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR3",&apcor3,
			      "Stellar aperture correction - 2x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR4",&apcor4,
			      "Stellar aperture correction - 2*sqrt(2)x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR5",&apcor5,
			      "Stellar aperture correction - 4x core flux",
			      &status);
	break;
    case 80:
	(void)fits_update_key(iptr,TFLOAT,"APCORPK",&apcpkht,
			      "Stellar aperture correction - peak height",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR1",&apcor1,
			      "Stellar aperture correction - 1/2x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR2",&apcor2,
			      "Stellar aperture correction - core/sqrt(2) flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR3",&apcor3,
			      "Stellar aperture correction - core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR4",&apcor4,
			      "Stellar aperture correction - sqrt(2)x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR5",&apcor5,
			      "Stellar aperture correction - 2x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR6",&apcor6,
			      "Stellar aperture correction - 2sqrt(2)x core flux",
			      &status);
	(void)fits_update_key(iptr,TFLOAT,"APCOR7",&apcor7,
			      "Stellar aperture correction - 4x core flux",
			      &status);
	break;
    }
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: can't update header %s -- %s",infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Write header information to help GAIA */

    (void)fits_write_comment(iptr,
        "Symbolic translation for GAIA ellipse plotting........",&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL1",
        "{Ellipticity Position_angle Areal_1_profile Classification} {el",
        NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL2",
        "lipse blue (1.0-$Ellipticity) $Position_angle+90 {} $Classific",
	NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL3",
	"ation==1} {sqrt($Areal_1_profile*(1.0-$Ellipticity)/3.142)} : {",
        NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL4",
        "Ellipticity Position_angle Areal_1_profile Classification} {el",
	NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL5",
        "lipse red (1.0-$Ellipticity) $Position_angle+90 {} $Classific",
        NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL6",
        "ation==-1} {sqrt($Areal_1_profile*(1.0-$Ellipticity)/3.142)} :",
        NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL7",
        "{Ellipticity Position_angle Areal_1_profile Classification} {el",
        NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL8",
        "lipse green (1.0-$Ellipticity) $Position_angle+90 {} $Classifi",
	NULL,&status);
    (void)fits_update_key(iptr,TSTRING,"SYMBOL9",
        "cation==0} {sqrt($Areal_1_profile*(1.0-$Ellipticity)/3.142)}",
        NULL,&status);
    if (status != 0) {
        fits_get_errstatus(status,msg);
        (void)sprintf(errmsg,"CLASSIFY: update header info %s -- %s",infile,msg);
        tidy();
        return(CIR_FATAL);
    }

    /* Close up and get out of here */

    closefits(iptr);
    tidy();
    return(CIR_OK);
}


static void anhist(float *data, int n, float *medval, float *sigma) {
    int i,*histo,ilev,imax,ismax;
    float *sval,hmax,smax,hlim,ratio;

    /* Get some workspace for the histogram */

    histo = cir_calloc(MAXHIST2,sizeof(int));
    sval = cir_calloc(MAXHIST2,sizeof(float));

    /* Sort data into the histogram */

    for (i = 0; i < n; i++) {
        ilev = cir_nint(data[i]/STEP);
        if (ilev >= -10 && ilev <= 100) {
 	    ilev += 10;
            histo[ilev] += 1;
        }
    }

    /* Now find the maximum of the histogram and its position... */

    hmax = 0.0;
    imax = 0;
    for (i = 0; i < MAXHIST2; i++) {
        if (histo[i] > hmax) {
 	    hmax = (float)histo[i];
            imax = i;
        }
    }

    /* Trap for hmax == 0 */

    if (hmax == 0) {
        if (n >= 10) {
	    *medval = data[(n+1)/2-1];
            *sigma = 1.48*0.5*(data[(3*n+3)/4-1] - data[(n+3)/4-1]);
        } else {
  	    *medval = 0.0;
	    *sigma = 1.0;
        }
        return;
    }

    /* Now do three point running average to see if there are other local
       maxima */

    smax = 0.0;
    ismax = 0.0;
    for (i = 1; i < MAXHIST2-1; i++) {
        sval[i] = (histo[i-1] + histo[i] + histo[i+1])/3.0;
        if (sval[i] > smax) {
  	    smax = sval[i];
            ismax = i;
        }
    }
    if (ismax < imax) {
        imax = ismax;
        hmax = histo[imax];
    }

    /* Now check for lower local maxima */

    for (i = imax-1; i > 0; i--) {
        if (sval[i] >= sval[i+1] && sval[i] >= sval[i-1]) {
	    if (sval[i] > 0.5*smax)
  	        ismax = i;
        }
    }
    if (ismax < imax) {
	imax = ismax;
        hmax = (float)histo[imax];
    }
    
    /* Now work out where the peak is */
    
    *medval = min((float)(imax-10)*STEP,data[(n+1)/2-1]);
    hlim = cir_nint(0.5*hmax);
    i = 1;
    while (histo[imax-i] > hlim && imax-i > 1)
        i++;
    ratio = hmax/max(1.0,(float)histo[imax-i]);
    *sigma = (float)i*STEP/(sqrt(2.0)*max(1.0,log(ratio)));
    *sigma = max(*sigma,0.5*STEP);

    /* Tidy and exit */
    
    free(histo);
    free(sval);
}


static void boundaries(float *core1, float *core2, float *core3, float medval1,
		       float sigma1, float medval2, float sigma2, int small, 
		       float area1, float area2, float *wt, float *avsig, 
		       float *lower, float *upper) {
    int i,n;
    float c1,c2,dc,*work,xnoise,xmag,xflux,ratio,asign,junk;

    /* Get a workspace */

    work = cir_malloc(nrows*sizeof(float));

    /* Initialise the lower boundary */

    lower[0] = cmin;
    lower[1] = cmax;
    asign = ((small == 1) ? -1.0 : 1.0);
    
    /* Now collect the data */

    n = 0;
    for (i = 0; i < nrows; i++) {
        c1 = core1[i];
        if (! poor) {
            c2 = core2[i];
            dc = asign*(c2 - c1);
            if (dc > medval1 - 3.0*sigma1 && c1 < blim - 3.0)
 	        work[n++] = dc - medval1;
	} else {
            c2 = core3[i];
            dc = c2 - c1;
            if (dc > medval2 - 3.0*sigma2 && c1 < blim - 3.0)
 	        work[n++] = dc - medval2;
        }
    }
 
    /* Find the median */

    medstat(work,n,avsig,&junk);
    free(work);

    /* Work out sigma levels for both types of seeing */

    if (! poor) {
        *wt = min(5.0,max(1.0,*avsig/sigma1));
        xnoise = sqrt(area1)*skynoise;
    } else {
        *wt = min(2.5,max(1.0,*avsig/sigma2));
        xnoise = sqrt(area2)*skynoise;
    }

    /* Now work out the boundaries */

    for (i = 0; i < NSAMPLE; i++) {
        xmag = 5.0 + (float)(i+1)*0.1;
        xflux = pow(10.0,(double)(0.4*xmag));
        ratio = COREMAG(1.0+xnoise/xflux,0.0,0.0);
        if (! poor) {
 	    lower[i] = medval1 - 3.0*sqrt(sigma1*sigma1 + ratio*ratio);
            upper[i] = medval1 + 3.0*sqrt(sigma1*sigma1 + 0.5*ratio*ratio);
        } else {
      	    lower[i] = medval2 - 3.0*sqrt(sigma2*sigma2 + ratio*ratio);
            upper[i] = medval2 + 3.0*sqrt(sigma2*sigma2 + 0.5*ratio*ratio);
        }
    }
    upper[0] = ((poor == 0) ? medval1 : medval2);
    upper[1] = upper[0];
}

static void boundpk(float *core, float *pkht, float medval, float sigma, 
                    float *wt, float *avsig, float *lower, float *upper) {
    int i,n;
    float c,p,*work,xnoise,xmag,pmag,xflux,pflux,ratio,junk;

    /* Get the space for the boundary lines and a workspace */

    work = cir_malloc(nrows*sizeof(float));

    /* Collect the data */

    n = 0;
    for (i = 0; i < nrows; i++) {
	c = core[i];
	p = pkht[i];
        if (c - p > medval - 3.0*sigma && c < blim - 3.0)
  	    work[n++] = c - p - medval;
    }

    /* Find the median */

    medstat(work,n,avsig,&junk);
    free(work);
    *wt = min(5.0,max(1.0,*avsig/sigma));

    /* Now work out boundaries */

    xnoise = sqrt(M_PI*rcore*rcore)*skynoise;
    for (i = 0; i < NSAMPLE; i++) {
        xmag = 5.0 + (float)(i+1)*0.1;
        pmag = xmag - medval;
        xflux = pow(10.0,(double)(0.4*xmag));
        pflux = pow(10.0,(double)(0.4*pmag));
        ratio = 2.5*log10((double)(1.0+max(xnoise/xflux,skynoise/pflux)));
        lower[i] = medval - 3.0*sqrt(sigma*sigma + ratio*ratio);
        upper[i] = medval + 3.0*sqrt(sigma*sigma + 0.5*ratio*ratio);
    }
    upper[0] = medval;
    upper[1] = upper[0];
}


static void classify() {
    float fluxlim,ell,pk,pkht,core,sig1,sig2,sig3,denom,w1,w2,w3,junk;
    float core_small,core_large,core_midd,statistic,statcut,sigtot,avsatnew;
    float fit0,sigma0,xnoise,xmag,ratio,xflux,ratell,ratscl,ellbound,*work;
    int i,iarg,ii;

    /* Update faint limit to cope with short exposures */

    blim = BLIMDEF;
    flim = FLIMDEF;
    fluxlim = 2.5*log10((double)(5.0*sqrt(M_PI*rcore*rcore)*skynoise));
    flim = min(flim,max(6.0,fluxlim+3.0));
    corlim = min(blim,max(12.5,fluxlim+5.0));
    cormin = min(blim,max(12.5,fluxlim+5.0));

    /* Work out min and max core flux */

    cmin = CMINDEF;
    cmax = CMAXDEF;
    for (i = 0; i < nrows; i++) {
	xflux = core_flux[i];
	cmin = min(cmin,xflux);
	cmax = max(cmax,xflux);
    }
    cmin = max(fluxlim-0.5,cmin);
    cmax += 0.1;
    cmax = min(cmax,20.0);

    /* Work out ellipticity stats for likely stellar objects */

    classstats_el();

    /* Ok, get the classification statistics for each of the tests.  First
       the core flux vs 1/2*core flux */

    classstats(core_flux,core1_flux,1,0.2,&fit1,&sigma1);

    /* Core flux vs 2*core flux */

    classstats(core_flux,core3_flux,0,0.1,&fit2,&sigma2);

    /* Core flux vs sqrt(2)*core flux */

    classstats(core_flux,core2_flux,0,0.0,&fit4,&sigma4);

    /* Core flux vs 2*sqrt(2)*core flux */

    classstats(core_flux,core4_flux,0,0.1,&fit5,&sigma5);

    /* Core flux vs Peak height */

    classstats(core_flux,peak_mag,1,0.2,&fit3,&sigma3);

    /* Faint end ellipticity */

    classstats_ellf(fluxlim);

    /* Work out the median PA */

    classstats_pa();

    /* Get workspace for the boundary arrays */

    lower1 = cir_malloc(NSAMPLE*sizeof(float));
    lower2 = cir_malloc(NSAMPLE*sizeof(float));
    lower3 = cir_malloc(NSAMPLE*sizeof(float));
    upper1 = cir_malloc(NSAMPLE*sizeof(float));
    upper2 = cir_malloc(NSAMPLE*sizeof(float));
    upper3 = cir_malloc(NSAMPLE*sizeof(float));

    /* Right, work out the boundaries for the classification tests 
       First core vs sqrt(2)*core or core vs 0.5*core depending upon
       the seeing */

    boundaries(core_flux,core1_flux,core2_flux,fit1,sigma1,fit4,sigma4,
	       1,M_PI*rcore*rcore,2.0*M_PI*rcore*rcore,&wt1,&avsig1,lower1,
	       upper1);

    /* Now core vs 2*core or core vs 2*sqrt(2)*core */

    boundaries(core_flux,core3_flux,core4_flux,fit2,sigma2,fit5,sigma5,
	       0,4.0*M_PI*rcore*rcore,8.0*M_PI*rcore*rcore,&wt2,&avsig2,lower2,
	       upper2);

    /* Now core vs peak height */

    boundpk(core_flux,peak_mag,fit3,sigma3,&wt3,&avsig3,lower3,upper3); 
     
    /* Do final classification statistics and find the saturation limit */

    classstats_final();

    /* Define final boundaries */

    lower = cir_malloc(NSAMPLE*sizeof(float));
    upper = cir_malloc(NSAMPLE*sizeof(float));
    uppere = cir_malloc(NSAMPLE*sizeof(float));
    xnoise = sqrt(M_PI*rcore*rcore)*skynoise;
    ratell = xnoise/pow(10.0,0.4*(fluxlim+1.5));
    ratell = COREMAG(1.0+ratell,0.0,0.0);
    ratscl = (pow((fitellf + 2.0*sigellf - fitell),2.0) - 4.0*sigell*sigell)/(4.0*ratell*ratell);
    ratscl = max(0.25,min(10.0,ratscl));
    for (i = 0; i < NSAMPLE; i++) {
        xmag = 5.0 + 0.1*(float)(i+1);
        xflux = pow(10.0,0.4*xmag);
        ratio = 2.5*log10(1.0+xnoise/xflux);
        lower[i] = fit_final - 5.0*sqrt(sigma_final*sigma_final + ratio*ratio);
        upper[i] = fit_final + sqrt(9.0*sigma_final*sigma_final + 0.0*ratio*ratio);
	uppere[i] = fitell + 2.0*sqrt(sigell*sigell + ratscl*ratio*ratio);
	uppere[i] = min(0.5,uppere[i]);
    }
    elllim = min(0.5,max(0.2,fitell+2.0*sigell));
    fluxlim = 2.5*log10((double)(2.5*sqrt(M_PI*rcore*rcore)*skynoise));

    /* Ok, final classification loop now... */

    nstar = 0;
    ngal = 0;
    njunk = 0;
    ncmp = 0;
    for (i = 0; i < nrows; i++) {
	ell = ellipticity[i];
        pk = peak_height[i] + skylevel;
	pkht = peak_mag[i];
	core = core_flux[i];
	iarg = cir_nint(10.0*(core - 5.0));
	iarg = max(1,min(NSAMPLE,iarg)) - 1;
	if (! poor) {
	    sig1 = max(0.01,(fit1 - lower1[iarg])/3.0);
	    sig2 = max(0.01,(fit2 - lower2[iarg])/3.0);
	} else {
	    sig1 = max(0.01,(fit4 - lower1[iarg])/3.0);
	    sig2 = max(0.01,(fit5 - lower2[iarg])/3.0);
	}
	sig3 = max(0.01,(fit3 - lower3[iarg])/3.0);
	denom = (wt1/sig1 + wt2/sig2 + wt3/sig3);
	w1 = (wt1/sig1)/denom;
	w2 = (wt2/sig2)/denom;
	w3 = (wt3/sig3)/denom;
	if (! poor) {
	    core_small = core1_flux[i];
	    core_large = core3_flux[i];
	    statistic = (core - core_small - fit1)*w1 + 
		(max(-3.0*sig2,core_large - core - fit2))*w2 + 
                (core - pkht - fit3)*w3;
	} else {
	    core_midd = core2_flux[i];
	    core_large = core4_flux[i];
	    statistic = (core_midd - core - fit4)*w1 +
		(max(-3.0*sig2,core_large - core - fit5))*w2 + 
                (core - pkht - fit3)*w3;
	}
        cls[i] = -1.0;
        statcut = upper[iarg] + 3.0*sigma_final*(exp(max(0.0,core-corlim+1.0)) - 1.0);
        if (statistic  >= statcut) 
 	    cls[i] = 1.0;
        else if (statistic <= lower[iarg])
  	    cls[i] = 0.0;

        /* Save distance from the stellar locus */

        sigtot = (fit_final - lower[iarg])/5.0;
        sig[i] = (statistic - fit_final)/sigtot;

        /* Right, now here are lots of overrides for special circumstances */
        /* Too spikey? -> junk */

        if (core - pkht - fit3 < -4.0*sig3) 
            cls[i] = 0.0;

        /* Elliptical star? -> compact */

	ellbound = max(elllim,uppere[iarg]);
        if (ell > ellbound && cls[i] == -1.0 && core < flim && sig[i] > -2.0)
	    cls[i] = -2.0;

        /* Saturated? -> star */

	if (core > corlim && statistic >= lower[iarg])
  	    cls[i] = -1.0;

	/* Too elliptical? -> junk */

        if (ell > 0.9 && core < corlim)
	    cls[i] = 0.0;

        /* Too faint? -> junk */

        if (core < fluxlim)
	    cls[i] = 0.0;

        /* Now count how many you have of each */

        if (cls[i] == -1.0)
	    nstar++;
        else if (cls[i] == 1.0)
	    ngal++;
	else if (cls[i] == -2.0)
	    ncmp++;
        else
	    njunk++;
    }

    /* Do stats to get the aperture corrections */

    if (ncols == 80) {
	classstats_ap67(core5_flux,core3_flux,&fit6,&sigma6);
	classstats_ap67(core_flux,core6_flux,&fit7,&sigma7);
	fit6 += fit2;
    }
    classstats_ap0(&fit0,&sigma0);
    if (ncols == 80) 
	fit0 = max(fit6,fit0);
    else
	fit0 = max(fit5,fit0);
    apcpkht = fit0 + fit3; /* pkht */
    switch (ncols) {
    case 32:
        apcor1 = fit0 + fit1;  /* 0.5*core */
        apcor = fit0;          /* core */
        apcor2 = fit0 - fit4;  /* sqrt(2)*core */
        apcor3 = fit0 - fit2;  /* 2*core */
        apcor4 = fit0 - fit5;  /* 2*sqrt(2)*core */
        apcor5 = 0.0;          /* 4*core */
	break;
    case 80:
        apcor1 = fit0 + fit1;      /* 0.5*core */
        apcor2 = fit0 + fit7;      /* 1/sqrt(2) * core */
        apcor3 = fit0;             /* core */
        apcor4 = fit0 - fit4;      /* core * sqrt(2) */
        apcor5 = fit0 - fit2;      /* 2*core */
        apcor6 = fit0 - fit5;      /* 2*sqrt(2)*core */
        apcor7 = fit0 - fit6;      /* 4*core */
	break;
    }

    /* Now do a better job on the saturation */

    ii = 0;
    work = cir_malloc(nrows*sizeof(float));
    for (i = 0; i < nrows; i++) {
	ell = ellipticity[i];
	core = core_flux[i];
	pkht = max(thresh,peak_height[i]) + skylev[i];
	if (((ell < elllim && core > flim && cls[i] == -1 && sig[i] >= 5.0 &&
	     areal[i] >= pixlim) || pkht >= 0.9*avsat) && xpos[i] >= xmin && 
	     xpos[i] <= xmax && ypos[i] >= ymin && ypos[i] <= ymax) {
	    work[ii++] = pkht;
	}
    }
    if (ii > 0) {
	medstat(work,ii,&avsatnew,&junk);
	avsatnew = max(10000.0+skylevel,avsatnew);
    } else {
        avsatnew = 10000.0 + skylevel;
    }
    avsat = avsatnew;
    freespace(work);

    /* Ok, now get rid of some workspace */
        
    free(lower1);
    free(lower2);
    free(lower3);
    free(upper1);
    free(upper2);
    free(upper3);
    free(lower);
    free(upper);
    free(uppere);

}

static void classstats(float *core1, float *core2, int small, float cutlev,
		       float *medval, float *sigma) {

    int i,iloop,n;
    float *work,*dc,sigmaold,amult;

    /* Initialise the output values to something stupid */

    *medval = 0.0;
    *sigma = 1.0e6;
    amult = (small == 1 ? -1.0 : 1.0);

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));
    dc = cir_malloc(nrows*sizeof(float));

    /* Work out differences */

    for (i = 0; i < nrows; i++)
	dc[i] = amult*(core2[i] - core1[i]);

    /* Do an iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        sigmaold = *sigma;
        n = 0;

        /* Ok, gather up all the stats */

        for (i = 0; i < nrows; i++) {
            
            /* Clipping criteria */

            if (ellipticity[i] < elllim && core1[i]< blim && core1[i] > flim &&
		fabs(dc[i] - *medval) < 3.0*(*sigma) &&
		xpos[i] >= xmin && xpos[i] <= xmax && ypos[i] >= ymin &&
		ypos[i] <= ymax && areal[i] >= pixlim) {
		if (iloop > 0 || (iloop == 0 && dc[i] >= cutlev)) 
  	            work[n++] = dc[i];
            }
        }

        /* Sort the work array and find the median and sigma */

	if (n > 0) {
            sort1(work,n);
	    if (iloop == 0) {
	        anhist(work,n,medval,sigma);
            } else {
  	        medstat(work,n,medval,sigma);
                *sigma = min(sigmaold,*sigma);
            }
	} else {
	    *medval = 0.0;
	    *sigma = 0.01;
	}

        /* Just in case... */

        *sigma = max(*sigma,0.01);
    }

    /* Tidy and exit */

    free(work);
    free(dc);
}

static void classstats_el() {
    int iloop,n,i;
    float *work;

    /* Initialise the mean and sigma to something stupid */

    sigell = 1.0e6;
    fitell = 0.0;

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));

    /* Do iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        n = 0;
        for (i = 0; i < nrows; i++) {
            if (ellipticity[i] < 0.5 && core_flux[i] < blim && 
		core_flux[i] > flim && 
		fabs(ellipticity[i] - fitell) < 2.0*sigell &&
		xpos[i] >= xmin && xpos[i] <= xmax && ypos[i] >= ymin &&
		ypos[i] <= ymax && areal[i] >= pixlim)
 	        work[n++] = ellipticity[i];
        }
	if (n > 2)
            medstat(work,n,&fitell,&sigell);
	else {
	    fitell = 0.25;
	    sigell = 0.05;
        }
    }
    elllim = min(0.5,max(0.2,fitell+2.0*sigell));

    /* Get out of here */

    free(work);
}

static void classstats_pa() {
    int iloop,n,i;
    float *work;

    /* Initialise the mean and sigma to something stupid */

    sigpa = 1.0e6;
    fitpa = 0.0;

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));

    /* Do iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        n = 0;
        for (i = 0; i < nrows; i++) {
            if (core_flux[i] < blim && core_flux[i] > flim && 
		fabs(posang[i] - fitpa) < 2.0*sigpa &&
		xpos[i] >= xmin && xpos[i] <= xmax && ypos[i] >= ymin &&
		ypos[i] <= ymax && areal[i] >= pixlim)
 	        work[n++] = posang[i];
        }
	if (n > 2)
            medstat(work,n,&fitpa,&sigpa);
	else {
	    fitpa = 0.0;
	    sigpa = 0.05;
        }
    }

    /* Get out of here */

    freespace(work);
}

static void classstats_ellf(float fluxlim) {
    int iloop,n,i;
    float *work;

    /* Initialise the mean and sigma to something stupid */

    sigellf = 1.0e6;
    fitellf = 0.0;

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));

    /* Do iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        n = 0;
        for (i = 0; i < nrows; i++) {
            if (ellipticity[i] < 0.75 && core_flux[i] > fluxlim+1.0 && 
		core_flux[i] < fluxlim+2.0 &&
		fabs(ellipticity[i] - fitellf) < 2.0*sigellf)
 	        work[n++] = ellipticity[i];
        }
	if (n > 2)
            medstat(work,n,&fitellf,&sigellf);
	else {
	    fitellf = 0.25;
	    sigellf = 0.05;
        }
    }

    /* Get out of here */

    free(work);
}

static void classstats_ap0(float *medval, float *sigma) {

    int i,iloop,n;
    float *work,*dc,c2,sigmanew;

    /* Initialise the output values to something stupid */

    *medval = 0.0;
    *sigma = 1.0e6;
    elllim = min(0.5,max(0.2,fitell+2.0*sigell));

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));
    dc = cir_malloc(nrows*sizeof(float));

    /* Work out differences */

    for (i = 0; i < nrows; i++) {
        c2 = max(0.0,max(iso_flux[i],core5_flux[i]));
        dc[i] = c2 - core_flux[i];
    }

    /* Do an iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        n = 0;

        /* Ok, gather up all the stats */

        for (i = 0; i < nrows; i++) {
            
            /* Clipping criteria */

            if (ellipticity[i] < elllim && core_flux[i] < blim && 
		core_flux[i] > flim && 
		fabs(dc[i] - *medval) < 3.0*(*sigma) && 
		cls[i] == -1.0 && sig[i] < 5.0 &&
		xpos[i] >= xmin && xpos[i] <= xmax && ypos[i] >= ymin &&
		ypos[i] <= ymax && areal[i] >= pixlim) 
		if (iloop > 0 || (iloop == 0 && dc[i] >= 0.0)) {
		    work[n++] = dc[i];
		}
        }

        /* Sort the work array and find the median and sigma */

	if (n > 0) {
            sort1(work,n);
            if (iloop == 0) {
	        anhist(work,n,medval,sigma);
		*sigma = 1.48*(*medval - work[(int)(0.25*(float)(n+3))-1]);
		*sigma = max(0.025,*sigma);
            } else {
  	        medstat(work,n,medval,&sigmanew);
		*sigma = min(*sigma,sigmanew);
		*sigma = max(0.01,*sigma);
            }
	} else {
	    *medval = 0.0;
	    *sigma = 0.01;
	}

        /* Just in case... */

        *sigma = max(*sigma,0.01);
    }

    /* Tidy and exit */

    free(work);
    free(dc);
}

static void classstats_ap67(float *mag1, float *mag2, float *medval, 
			    float *sigma) {

    int i,iloop,n;
    float *work,*dc,sigmanew;

    /* Initialise the output values to something stupid */

    *medval = 0.0;
    *sigma = 1.0e6;
    elllim = min(0.5,max(0.2,fitell+2.0*sigell));

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));
    dc = cir_malloc(nrows*sizeof(float));

    /* Work out differences */

    for (i = 0; i < nrows; i++) 
        dc[i] = mag1[i] - mag2[i];

    /* Do an iteration loop */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        n = 0;

        /* Ok, gather up all the stats */

        for (i = 0; i < nrows; i++) {
            
            /* Clipping criteria */

            if (ellipticity[i] < elllim && core_flux[i] < blim && 
		core_flux[i] > flim && 
		fabs(dc[i] - *medval) < 3.0*(*sigma) && 
		cls[i] == -1.0 && sig[i] < 5.0 &&
		xpos[i] >= xmin && xpos[i] <= xmax && ypos[i] >= ymin &&
		ypos[i] <= ymax && areal[i] >= pixlim) {
		if (iloop > 0 || (iloop == 0 && dc[i] >= 0.0)) {
		    work[n++] = dc[i];
		}
	    }
        }

        /* Sort the work array and find the median and sigma */

	if (n > 0) {
            sort1(work,n);
            if (iloop == 0) {
	        anhist(work,n,medval,sigma);
		*sigma = 1.48*(*medval - work[(int)(0.25*(float)(n+3))-1]);
		*sigma = max(0.025,*sigma);
            } else {
  	        medstat(work,n,medval,&sigmanew);
		*sigma = min(*sigma,sigmanew);
		*sigma = max(0.01,*sigma);
            }
	} else {
	    *medval = 0.0;
	    *sigma = 0.01;
	}

        /* Just in case... */

        *sigma = max(*sigma,0.01);
    }

    /* Tidy and exit */

    free(work);
    free(dc);
}

static void classstats_final() {
    int n,i,iloop,iarg,ii,iend,ncls,kk,k;
    float *work,ell,core,sig1,sig2,sig3,denom,w1,w2,w3,core_small;
    float core_large,*statistic,core_midd,pkht,xcor,cfit,csig;
    float *work1,junk,corlim1,corval1,corlim2,corval2,sigmaold;

    /* Initialise */

    sigma_final = 1.0e6;
    fit_final = 0.0;
    ncls = 0;

    /* Get some workspace */

    work = cir_malloc(nrows*sizeof(float));
    work1 = cir_malloc(nrows*sizeof(float));
    statistic = cir_malloc(nrows*sizeof(float));

    /* Calculate the statistic now */

    for (i = 0; i < nrows; i++) {
	ell = ellipticity[i];
	pkht = peak_mag[i];
	core = core_flux[i];
	iarg = cir_nint(10.0*(core - 5.0));
	iarg = max(1,min(NSAMPLE,iarg)) - 1;
	if (! poor) {
	    sig1 = max(0.01,(fit1 - lower1[iarg])/3.0);
	    sig2 = max(0.01,(fit2 - lower2[iarg])/3.0);
	} else {
	    sig1 = max(0.01,(fit4 - lower1[iarg])/3.0);
	    sig2 = max(0.01,(fit5 - lower2[iarg])/3.0);
	}
	sig3 = max(0.01,(fit3 - lower3[iarg])/3.0);
	denom = (wt1/sig1 + wt2/sig2 + wt3/sig3);
	w1 = (wt1/sig1)/denom;
	w2 = (wt2/sig2)/denom;
	w3 = (wt3/sig3)/denom;
	if (! poor) {
	    core_small = core1_flux[i];
	    core_large = core3_flux[i];
	    statistic[i] = (core - core_small - fit1)*w1 + 
		(core_large - core - fit2)*w2 + (core - pkht - fit3)*w3;
	} else {
	    core_midd = core2_flux[i];
	    core_large = core4_flux[i];
	    statistic[i] = (core_midd - core - fit4)*w1 +
		(core_large - core - fit5)*w2 + (core - pkht - fit3)*w3;
	}
    }

    /* Iteration loop.  Use only lower ellipticity images and relevant
       peak height range */

    for (iloop = 0; iloop < MAXLOOP; iloop++) {
        sigmaold = sigma_final;
        n = 0;
        for (i = 0; i < nrows ; i++) {
  	    ell = ellipticity[i];
 	    core = core_flux[i];
   	    if (ell < elllim && core < blim && core > flim &&
	        fabs((double)(statistic[i] - fit_final)) < 3.0*sigma_final &&
		areal[i] >= pixlim)
	        work[n++] = statistic[i];

	    /* This information is to be used later to find the curvature of 
               saturated region */

            if (core > corlim && iloop == MAXLOOP-2) {
 	        cls[ncls] = statistic[i];
                sig[ncls++] = core;
            }
        }

        /* Median defines general fit */

	if (n > 2) {
            sort1(work,n);
            if (iloop == 0 && n > 10) {
                anhist(work,n,&fit_final,&sigma_final);
            } else {
	        medstat(work,n,&fit_final,&sigma_final);
            }
            sigma_final = max(0.01,min(sigmaold,sigma_final));
	} else {
	    fit_final = 0.0;
	    sigma_final = 0.01;
        }
    }

    /* Now work out the curvature in the saturated region */

    sort2(sig,cls,ncls);
    ii = 0;
    xcor = 12.5;
    iend = 0;
    i = -1;
    corlim1 = 0.0;
    corlim2 = 0.0;
    corval1 = 0.0;
    corval2 = 0.0;
    while (iend == 0 && i < ncls-1) {
        i++;
        if (sig[i] > xcor+0.25 && ii >= 3) {
	    medstat(work,ii,&cfit,&csig);
            for (iloop = 0; iloop < 3; iloop++) {
	        kk = 0;
                for (k = 0; k < ii; k++) {
		    if (work[k] <= cfit + 3.0*csig)
		        work1[kk++] = work[k];
                }
                medstat(work1,kk,&cfit,&junk);
	    }
            if (cfit <= fit_final + 3.0*sigma_final) {
	        corlim1 = xcor;
                corval1 = cfit;
	    } else {
	        corlim2 = xcor;
                corval2 = cfit;
                iend = 1;
            }
	    xcor += 0.5;
	    ii = 0;
	} else {
 	    work[ii++] = cls[i];
        }
    }

    /* Estimate where core measure and statistic become unreliable */

    if (iend == 1) 
        corlim = corlim2 - 0.5*(corval2 - fit_final - 3.0*sigma_final)/(corval2 - corval1);
    else 
        corlim = corlim1;
    corlim = max(cormin,corlim);
    kk = 0;
    for (i = 0; i < nrows; i++) {
        core = core_flux[i];
        if (core >= corlim)
	    work[kk++] = peak_height[i] + skylevel;
    }
    if (kk > 0) {
	medstat(work,kk,&avsat,&junk);
	avsat = max(10000.0+skylevel,avsat);
    } else {
	avsat = 10000.0 + skylevel;
    }

    /* Tidy and exit */
  
    free(work);
    free(work1);
    free(statistic);
}


static void medstat(float *array, int n, float *medval, float *sigval) {
    int lev1,lev2,lev3;

    /* Sort the array first, then choose the median.  The sigma is defined
       as half the distance between the two quartile points multiplied by
       the appropriate scaling factor (1.48) */

    sort1(array,n);
    lev1 = (n + 1)/2;
    lev2 = (3*n + 3)/4;
    lev3 = (n + 3)/4;

    *medval = array[lev1-1];
    *sigval = 1.48*0.5*(array[lev2-1] - array[lev3-1]);
}


static void sort1(float *a, int n) {
    int iii,ii,i,ifin,j;
    float b;

    iii = 4;
    while (iii < n)
        iii *= 2;
    iii = min(n,(3*iii)/4 - 1);

    while (iii > 1) {
        iii /= 2;
        ifin = n - iii;
        for (ii = 0; ii < ifin; ii++) {
            i = ii;
            j = i + iii;
            if (a[i] > a[j]) {
                b = a[j];
                while (1) {
                    a[j] = a[i];
                    j = i;
                    i = i - iii;
                    if (i < 0 || a[i] <= b) 
                        break;
                }
                a[j] = b;
            }
        }
    }
}

static void sort2(float *a1, float *a2, int n) {
    int iii,ii,i,ifin,j;
    float b1,b2;

    iii = 4;
    while (iii < n)
        iii *= 2;
    iii = min(n,(3*iii)/4 - 1);

    while (iii > 1) {
        iii /= 2;
        ifin = n - iii;
        for (ii = 0; ii < ifin; ii++) {
            i = ii;
            j = i + iii;
            if (a1[i] > a1[j]) {
                b1 = a1[j];
                b2 = a2[j];
                while (1) {
                    a1[j] = a1[i];
                    a2[j] = a2[i];
                    j = i;
                    i = i - iii;
                    if (i < 0 || a1[i] <= b1) 
                        break;
                }
                a1[j] = b1;
                a2[j] = b2;
            }
        }
    }
}

static void write_pa(char *infile, fitsfile *iptr, float pa) {
    int gotwcs,status;
    double theta_north,theta_east,theta_north_2;
    struct wcsprm *wcs;
    char errmsg[BUFSIZ];

    /* Try to read the WCS */

    gotwcs = (cir_wcsopen(infile,&wcs,errmsg) == CIR_OK);

    /* If a WCS exists then try to work out the orientation of the celestial
       axes. From that you can convert the PA to degrees from North in
       the direction of East */

    if (gotwcs) {
	theta_north = atan2(wcs->cd[3],wcs->cd[2])/DEGRAD;
	theta_north_2 = (theta_north < 0.0 ? theta_north + 360.0 : theta_north);
	theta_east = atan2(wcs->cd[1],wcs->cd[0])/DEGRAD;
	if (abs(theta_north-theta_east-90.0) < 5.0 ||
	    abs(theta_north-theta_east+270.0) < 5.0) {
	    pa = theta_north_2 - pa;
	} else {
	    pa = 360.0 - theta_north_2 + pa;
	}
	if (pa < 0.0)
	    pa += 360.0;
	if (pa > 180.0)
	    pa -= 180.0;
	(void)sprintf(errmsg,"[deg] Mean PA from N to E");
	cir_wcsclose(wcs);
    } else {
	(void)sprintf(errmsg,"[deg] Mean PA from X to Y");
    }

    /* Write the PA key now */

    status = 0;
    (void)fits_update_key(iptr,TFLOAT,"MED_PA",&pa,errmsg,&status);
}	

static void tidy() {
    int status;

    /* Free some workspace */

    freespace(workspace);
    freespace(areal);

    /* Close up the fits file */

    closefits(iptr);
}


/*

$Log: cir_classify.c,v $
Revision 1.11  2012/12/05 11:50:23  jim
Traps for WFCAM data and changes the moffet profile exponent

Revision 1.10  2012-01-04 10:17:42  jim
Put some sensible lower limits to sigma in routines _ap67 and _ap0

Revision 1.9  2011-02-14 12:29:01  jim
Fixed bug in classstats_final where curvature was being estimated
incorrectly

Revision 1.8  2011-02-01 15:34:40  jim
Fixed mistaken column ID

Revision 1.7  2011-01-31 15:04:00  jim
Modified to do a better job at estimating saturation

Revision 1.6  2011-01-19 12:46:16  jim
Fixed position angle calculation so that it's in the range [0,180]

Revision 1.5  2011-01-18 12:22:39  jim
a few very minor tweaks

Revision 1.4  2011-01-14 10:52:26  jim
Small fix to remove the rare chance of seg fault

Revision 1.3  2011-01-12 13:14:03  jim
Modified to do aperture correction for apertures 2 and 7 correctly. Also
works out a median position angle and writes it to the header. Isophotal
flux is modified to look like a moffat flux for beta = 2.5

Revision 1.2  2010-10-05 09:15:59  jim
The core magnitude isn't calculated for total_flux now unless it's actually
been read

Revision 1.1.1.1  2010-07-27 08:41:20  jim
Imported casutools

Revision 1.19  2010/02/05 10:03:54  jim
Took out reference to hall flux

Revision 1.18  2009/11/15 18:43:19  jim
Many little mods and bug fixes to bring into line with Mike's latest version

Revision 1.17  2009/10/29 14:28:01  jim
Fixed typo in classstats

Revision 1.16  2009/09/29 16:45:13  jim
Mods to lower chance of stupid seeing estimates

Revision 1.15  2006/03/17 11:30:27  jim
Fixed the way iptr is closed

Revision 1.14  2005/09/21 12:02:32  jim
Fixed column name that was FWHM_flux to Hall_flux

Revision 1.13  2005/05/19 13:31:22  jim
Modified to swap around the aperture flux columns so that they are in
size order

Revision 1.12  2005/05/13 09:25:16  jim
More modifications for 80 column files

Revision 1.11  2005/04/20 11:10:36  jim
Modified so that both 32 and 80 column catalogues are understood.
Also fixed bug in definition of fwhm

Revision 1.10  2005/04/20 07:48:27  jim
Modified estimate of seeing allowing for undersampled data

Revision 1.9  2004/11/02 12:39:30  jim
Fixed bug affecting the aperture correction calculation.

Revision 1.8  2004/09/07 14:18:51  jim
Tidied up so that strict compilation doesn't throw up loads of warnings

Revision 1.7  2004/08/26 07:42:13  jim
Modified to bring it up to date with MJI's latest version

Revision 1.6  2004/08/19 11:34:23  jim
Added new cir_memory routines for memeory allocation

Revision 1.5  2004/04/05 11:26:29  jim
Modified for new version of imcore

Revision 1.4  2003/09/11 11:58:09  jim
Modified to use revised statistics routines

Revision 1.3  2003/02/03 09:32:36  jim
Added history logging

Revision 1.2  2002/12/16 10:22:38  jim
Made internal routines static.  Added prologue.

Revision 1.1.1.1  2002/06/21 09:48:57  jim
Initial import into CVS


*/
